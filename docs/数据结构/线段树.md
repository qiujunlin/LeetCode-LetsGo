1

数组不变，区间查询：前缀和、树状数组、线段树；
数组单点修改，区间查询：树状数组、线段树；
数组区间修改，单点查询：差分、线段树；
数组区间修改，区间查询：线段树。

# 差分数组

## 一维差分

设原数组为a数组，差分数组为d数组，则对于i∈[2,n],都有d[i]=a[i]-a[i-1].

1.当我们需要更新区间[l,r]时候（仅指加减运算），我们仅仅可以只更新d[l]+=x,d[r+1]-=x;

2.当我们需要单独查询原数组一个点的值的时候，我们不难发现出令$S_n$为d[i]的[前缀和](https://so.csdn.net/so/search?q=前缀和&spm=1001.2101.3001.7020)，那么a[i]= $S_n$

## 二维差分 ：



对于 左上角坐标 （a，b），右下角坐标 （x,y） 差分数组的定义形式就是 

```
	sum[a][b]++;      //a,b 为左上角坐标
    sum[a][y + 1]--;   // x,y 为右下角坐标
    sum[x + 1][b]--;
    sum[x + 1][y + 1]++;
```

![](/images/2.png)

对于二维数组求和 ：区间 左上角坐标 （a，b），右下角坐标 （x,y）的和为 



```
sum[x][y]+ sum[a-1][b-1] - sum[x][b-1] -sum[x-1][y]
```

![](/images/1.png)



#  树状数组

### 树状数组

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200220103617796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
如图，对于一个长度为n的数组，A数组存放的是数组的初始值，引入一个辅助数组C；

```
C1 = A1
C2 = C1 + A2 = A1 + A2
C3 = A3
C4 = C2 + C3 + A4 = A1 + A2 + A3 + A4
C5 = A5
C6 = C5 + A6 = A5 + A6
C7 = A7
C8 = C4 + C6 + C7 + A8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8
```

我们称`C[i]`的值为下标为`i`的数所管辖的数的和，下标为`i`的数所管辖的元素的个数为2 k 2^k2*k*个（`k`为`i`的二进制的末尾0的个数），例如：

- `i = 8 = 1000`，末尾3个0，故`k = 3`，所管辖的个数为$2^3 = 8 $，`C8`是8个数的和；
- `i = 5 = 0101`，末尾没有0，故`k = 0`，所管辖的个数为$2^0 =1$，`C5`是一个数的和；

而对于输入的数m，我们要求编号为m的数的前缀和$A_1 \cdots A_m$，按照上面说的，$sum_m = C_{i1 }+ C_{i2} + \cdots⋯$，这里`m`和`C[i]`的对应关系是这样的，对于查询的m，将它转换成二进制后，不断对末尾的1的位置进行-1的操作，直到全部为0停止，中间得到的值就是`c[i]`，例如：

- `m = 7`，$sum_7 = C_7 + C_6 + C_4$，7的二进制为`0111`（$C_7$得到），对`0111`的末尾1的位置-1，得到`0110 = 6`（$C_6$得到），再对`0110`末尾1位置-1，得到`0100 = 4`（$C_4$得到），最后对`0100`末尾1位置-1后得到`0000`（结束），计算停止，至此$C_7，C_6 ， C_4 $全部得到，求和后就是`m = 7`时它的前缀和；
- `m = 6`，$sum _6 = C _6 + C_4$ ，6的2进制等于·0110·，经过两次变换后为`0100`（C4）和`0000`（结束信号），那么求和后同样也得到了预计的结果；

那么求前缀和的代码如下：

```cpp
int lowbit(int m){
    return m & (-m);
}

int getSum(int m){
	int ans = 0;
    while(m > 0){
        ans += C[m];
        m -= lowbit(m);
    }
    return ans;
}
123456789101112
```

关于`m & (-m)`这是一个很巧妙的地方，用来求二进制数的最后一位。如13的二进制表示为`1101`，那么-13的二进制表示为`0010 + 0001 = 0011`，那么`1101 & 0011 = 0001`，二进制末尾1的位置是 $2^0$，将`13 - 0001 = 12`，再对12执行`lowbit`操作，`1100 & 0100 = 0100`，二进制末尾1的位置是$2^2$，将`12 - 0100 = 8`，再对8执行`lowbit`操作，`0100 & 1100 = 0100`，二进制位是  $2^2$，8 - 0100 = 0（结束操作），通过循环得到的13，12，8，则 $sum_{13} = C_{13} + C_{12} + C_8$.

### 建立树状数组

对于一个输入的数组A，我们一次读取的过程，就可以想成是一个不断更新值的过程，所以建树与单点更新值是一样的，即把$A_1 ⋯ A_n$从0更新成我们输入的`A[i]`，所以一边读入`A[i]`，一边将C[i]涉及到的祖先节点值更新，完成输入后树状数组C也就建立成功了。

下面说说如何更新节点值：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200220114220186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
假设更新`A[2] = 5`，通过观察我们得知，如果修改了A[2]的值，那么管辖`A[2]`的`C[2]，C[4]，C[8]`的前缀和都要加上5（所有的祖先节点），那么和查询类似，我们如何得到`C2`的所有祖先节点呢，依旧是上述的巧妙的方法，但是我们把它倒过来用，对于要更新`i`位置的值，我们把`i`转换成二进制，不断对二进制最后一个1的位置+1，直到达到数组下标的最大值n结束，对于给出的例子`i = 2`，假设数组下标上限`n = 8`，`i`转换成二进制后等于`0010`（C 2 C_2*C*2​），对末尾1的位置进行+1，得到`0100`（C 4 C_4*C*4​），对末尾的1的位置进行+1，得到`1000`（C 8 C_8*C*8​），循环结束，对C 2 ， C 4 ， C 8 C_2，C_4，C_8*C*2​，*C*4​，*C*8​的前缀和都要+5，当然不能忘记对`A[2]`的值+5，单点更新值过程结束。

```cpp
void update(int x, int value){
    A[x] += value;	// 修改源数组
    while(x <= n){
        C[x] += value;
        x += lowbit(x);
    }
}
```



模板：

```java
// 上来先把三个方法写出来
{
    int[] tree;
    int lowbit(int x) {
        return x & -x;
    }
    // 查询前缀和的方法
    int query(int x) {
        int ans = 0;
        for (int i = x; i > 0; i -= lowbit(i)) ans += tree[i];
        return ans;
    }
    // 在树状数组 x 位置中增加值 u
    void add(int x, int u) {
        for (int i = x; i <= n; i += lowbit(i)) tree[i] += u;
    }
}

// 初始化「树状数组」，要默认数组是从 1 开始
{
    for (int i = 0; i < n; i++) add(i + 1, nums[i]);
}

// 使用「树状数组」：
{   
    void update(int i, int val) {
        // 原有的值是 nums[i]，要使得修改为 val，需要增加 val - nums[i]
        add(i + 1, val - nums[i]); 
        nums[i] = val;
    }
    
    int sumRange(int l, int r) {
        return query(r + 1) - query(l);
    }
}

```

