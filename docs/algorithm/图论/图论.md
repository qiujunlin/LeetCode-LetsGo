## 785判断二分图

![](image/785.png)

有bfs和dfs两种解法 ,参考官方题解或者算法4

### 解法一 dfs

```java
class Solution {
  public boolean isBipartite(int[][] graph) {
       //创建邻接链表
        int len = graph.length;
        boolean vis[] = new boolean[len];
        boolean color[] = new boolean[len];
        for(int i=0;i<len;i++){
            if(!vis[i]){
               boolean res =  dfs(graph,color,vis,i);
               if(!res) return  false;
            }
        }
        return  true;
    }
    boolean dfs(int graph[][], boolean color[],boolean vis[],int s){
         vis[s] = true;
         for(int a : graph[s]){
             if(!vis[a]){
             color[a] = !color[s];
            boolean flag = dfs(graph,color,vis,a);
            if(!flag) return flag;
             }else{
                 if(color[a]==color[s])  return  false;
             }
         }
         return  true;
    }
}
//创建 
```

### 解法二 BFS

```JAVA
 boolean bfs(int graph[][], boolean color[], boolean vis[], int s) {
        Queue<Integer> queue = new LinkedList<>();
        queue.add(s);
        vis[s] =true;
        while (!queue.isEmpty()) {
            int a = queue.poll();
            for (int c : graph[a]) {
                if (!vis[c]) {
                    color[c] = !color[a];
                    queue.offer(c);
                    vis[c] =true;
                }
                else{
                    if (color[a] == color[c]) return false;
                }
            }
        }
        return  true;
        }
```



## 1743 从相邻元素还原数组

## 解法一 领接表

这道题的思路 

* 用领接表表示每一个节点的所有相邻的节点
* 遍历邻接表，找出与之相邻的节点只有一个的节点，这个节点就是起点
* 遍历领接表，组合数组

```java
    public int[] restoreArray(int[][] adjacentPairs) {
        HashMap<Integer, LinkedList<Integer>> map = new HashMap();
        for (int a[] : adjacentPairs) {
            map.put(a[0], map.getOrDefault(a[0], new LinkedList()));
            map.get(a[0]).offer(a[1]);
            map.put(a[1], map.getOrDefault(a[1], new LinkedList()));
            map.get(a[1]).offer(a[0]);
        }
        int start = 0;
        for (int a : map.keySet()) {
            if (map.get(a).size() == 1) start = a;
        }
        int res[] = new int[adjacentPairs.length + 1];
        int pre = start;
        res[0] = start;
        for (int i = 1; i < res.length; i++) {
            LinkedList<Integer> list = map.get(pre);
            System.out.print(list);
            if (i == 1) {
                res[i] = list.get(0);
                pre = res[i];
                continue;
            }
            for (int a : list) {
                if (res[i - 2] != a) {
                    res[i] = a;
                    pre = a;
                    break;
                }
            }

        }
        return res;
    }
```

