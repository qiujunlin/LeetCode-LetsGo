模板

解决的问题？

4   1095  33  153  

## 4.寻找正序列数组的中位数

### 解法一：暴力

其实就是将两个数组合并，求中位数，没有什么难度

### 解法二：归并排序



### 解法三 ：二分查找

```

```

## 33. 搜索旋转排序数组

题意：在旋转的排序数组中查找目标值



## 34.在排序数组中查找元素的第一个和最后一个位置

这道题和704 二分查找的题目类似，但是更细节，在数组中出现了重复的元素的处理方式。



```java
 public int[] searchRange(int[] nums, int target) {
         if(nums.length==0) return new int[]{-1,-1} ;
         int left = findleft(nums,target);
         if(nums[left] != target) return new int[]{-1,-1};
         int right = findright(nums, target);
         return new int[]{left,right};
    }
     int findleft(int[] nums,int target){
             int left=0;
             int right = nums.length - 1;
             while(left < right){
                 int mid= left + (right - left) / 2;
                 if(nums[mid]<target){
                     left=mid+1;
                 }else{
                     right=mid;
                 }
             }
             return left;
        }
        int findright(int[] nums,int target){
             int left=0;
             int right = nums.length - 1;
             while(left < right){
                 int mid= left + (right - left + 1 )/2;
                 if(nums[mid] > target){
                   right = mid - 1;
                 }else{
                     left = mid;
                 }
             }
             return left;
        }

```



## 35 搜索插入位置

```java
 public int searchInsert(int[] nums, int target) {
            int left=0;int right=nums.length;
            while(left<right){
                int mid=left+(right-left)/2;
                if(target>nums[mid]){
                    //right=mid-1;
                    left=mid+1;
                }else{
                    right=mid;
                }
            }
            return left;

    }
```



## 374. 猜数字大小

这道题看个题太脑壳大了，

```java
  public int guessNumber(int n) {
        int left=1;
        int right=n;
        while(left<right){
            int mid=left+(right-left)/2;
            int a=guess(mid);
            if(a==0) return mid;
            else if(a<0) right=mid-1;
            else left=mid+1;
        }
        return left;
    }
```



## 704 二分查找



```java
 public int search(int[] nums, int target) {
     int left=0;
     int right=nums.length-1;
     int mid;
     while(left<=right){
         mid=left+(right-left)/2;
         if(nums[mid]==target) return mid;
         else if(nums[mid]<target){
             left=mid+1;
         }
         else if(nums[mid]>target) right=mid-1;
     }
     return -1;
    }
```

## 1095. 山脉数组中查找目标值

经典的二分查找题目

在山脉数组中查找目标值为target的最小 下标

方法：

1. 先用二分查找找最大值

2. 用二分查找在左边数组查目标值

3. 用二分查找在右边数组中查找最大值

   代码：

   ```java
    public int findInMountainArray(int target, MountainArray mountainArr) {
           int peek = findmax(mountainArr);
           int leftindex=findleft(target,peek,mountainArr);
           int rightindex=findright(target,peek,mountainArr);
           int res =  Math.min(leftindex,rightindex);
            return res==Integer.MAX_VALUE?-1:res;
       }
       int findmax(MountainArray mountainArr){
           int left=0;int right=mountainArr.length()-1;
           
           while(left<right){
            int mid = left + (right-left)/2;
            int peek=mountainArr.get(mid);
            //int leftpeek=mountainArr.get(mid-1);
            int rightpeek=mountainArr.get(mid+1);
            if(peek<rightpeek) left=mid+1;
            else right=mid;
              }
           return left;
   
       }
       int findleft(int target,int peek,MountainArray mountainArr){
           int left=0;int right=peek;
           while(left<right){
               int mid = left + (right - left) / 2;
               if(mountainArr.get(mid)<target){
                   left=mid+1;
               }else right=mid;
           }
           return mountainArr.get(left)==target?left:Integer.MAX_VALUE;
       }
        int findright(int target,int peek,MountainArray mountainArr){
           int left=peek;int right=mountainArr.length()-1;
           while(left<right){
               int mid = left + (right - left) / 2;
               if(mountainArr.get(mid)>target){
                   left=mid+1;
               }else right=mid;
           }
           return mountainArr.get(left)==target?left:Integer.MAX_VALUE;
       }
   ```

   